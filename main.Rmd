---
title: "Álgebra Lineal: Ejercicio Cuadrados Mínimos"
author: "Gonzalo Barrera Borla"
date: "Noviembre 21, 2017"
header-includes:
   - \usepackage{amsmath}
output: 
  html_document
---

```{r knitr_options, include=FALSE}
library(knitr)
opts_chunk$set(fig.width=12, fig.height=6, message=FALSE, comment=NA)
```

# Acondicionamiento Inicial
## Carga de librerías

```{r librerias}
library(dplyr)
library(ggplot2)
```

## Carga de datos y variables básicas

La tabla detallando la cantidad de pobladores de San Luis Potosí - México, para años seleccionados entre 1970 y 2015 (expresada en millones) fue transcripta a un archivo CSV con codificación UTF-8 de dos columnas:

- `anio`, y
- `poblacion`.

```{r carga_datos}
datos <- read.csv("datos.csv")
```

La variable dependiente $y$ será la población de San Luis Potosí, y la variable independiente $t$ el año para el que fue medida. $n$ es el número de observaciones del que disponemos.

Por conveniencia, definimos también `uno` ($\vec{1}$), un "vector unitario", con unos en todos sus elementos.

_NOTA: En R, `t` es el nombre de la función que transpone matrices, por lo cual la variable $t$ es representada con el símbolo `tt`._

```{r variables_basicas}
n <- dim(datos)[1]
y <- datos$poblacion
tt <- datos$anio
uno <- rep.int(1, n)
```

# Ajuste lineal

## Aspectos generales del ajuste por cuadrados mínimos

Sea $z_{lin}(t)$ la estimación lineal de la población para el año $t$:

$$
z_{lin}(t) = b_{lin} + a_{lin} \times t
$$
Sean el vector $x^{*}_{lin}$ y $A_{lin}$ la matriz asociada al modelo recién descrito
$$
x^{*}_{lin} = \begin{pmatrix} b_{lin} \\ a_{lin} \end{pmatrix},
A_{lin} = \begin{pmatrix} 1 & t_1 \\ 1 & t_2 \\ \dots & \dots \\ 1 & t_n \end{pmatrix}
$$
, podemos reescribir vectorialmente $Z_{lin}$ para todas las observaciones como
$$
z_{lin} = A_{lin} \cdot x^{*}_{lin}
$$

Si elegimos los coeficientes de $x^{*}_{lin}$ de forma que $z_{lin}$ sea la proyección ortogonal de $y$ sobre el subespacio definido por los vectores $\langle 1, t \rangle$, sabremos con seguridad que estamos minimizando $\Vert y - z_{lin} \Vert$. Además, $y - z_{lin}$ será ortogonal a ambos vectores, $1$ y $t$.

Este planteo puede ser resumido en la siguiente "ecuación normal":

$$
\begin{align}
A^{t} \cdot (y-A \cdot x^{*}_{lin}) &= 0 \\
A^{t} \cdot y- A^{t} \cdot A \cdot x^{*}_{lin} &= 0 \\
A^{t} \cdot y &= A^{t} \cdot A \cdot x^{*}_{lin}
\end{align}
$$

y siempre y cuando $A^{t} \cdot A$ sea invertible, podemos encontrar $x^{*}_{lin}$ como

$$
\begin{align}
(A^{t} \cdot A)^{-1} \cdot A^{t} \cdot y &= (A^{t} \cdot A)^{-1} \cdot A^{t} \cdot A \cdot x^{*}_{lin} \\
(A^{t} \cdot A)^{-1} \cdot A^{t} \cdot y &= I \cdot x^{*}_{lin} \\
x^{*}_{lin} &= (A^{t} \cdot A)^{-1} \cdot A^{t} \cdot y \\
\end{align}
$$

A continuación, el código para calcular $x^{*}_{lin}$ según el método antes descrito:
```{r ajuste_lineal}
A_lin <- matrix(c(uno, tt), nrow = n)

# Sea C = A^t * A, y  d = A^t * y. Luego, podemos obtener x como C^-1 %*% d, que se implementa como solve(C,d)
C_lin <- t(A_lin) %*% A_lin
d_lin <- t(A_lin) %*% y
x_lin <- solve(C_lin, d_lin)
```

## Especificación del modelo

Para recrear la fórmula inicial $z_{lin}(t) = b_{lin} + a_{lin} \times t$, extraigo los coeficientes $(b_{lin}, a_{lin})$ y la codificamos en un método de R.


```{r est_lin}
b_lin <- x_lin[1]
a_lin <- x_lin[2]
est_lin <- function(x) { b_lin + a_lin * x}
```

que es equivalente a

$$
z_{lin}(t) = `r b_lin` + `r a_lin` \times t
$$

## Cálculo del error asociado al modelo lineal

Sea el error total del modelo
$$
ET_{lin} = \Vert y - z_{lin} \Vert = \sum\limits_{i=1}^n (y_{i} - z_{lin,i})^2
$$

Se lo puede calcular como
```{r error_lineal}
z_lin <- A_lin %*% x_lin
# Alternativamente, z_lin = est_lin(tt)
err_lin <- (y-z_lin)^2
et_lin <- sqrt(sum(err_lin))
```

de forma que 
$$
ET_{lin} = `r et_lin`
$$

## Estimación lineal de la poblacion para el 2030

Contando con la función `est_lin`, la estimación lineal de la población para 2030 se consigue como
```{r estimacion_lineal}
est_2030_lin <- est_lin(2030)
```
... que arroja una población estimada de `r est_2030_lin` millones de habitantes.

# Ajuste modelo potencial

Hasta aquí, hemos visto cómo ajustar por la técnica de cuadrados mínimos un modelo _lineal_ sobre las variables independientes. Por lo tanto, un modelo donde la estimación depende de una función _potencial_ (no estoy seguro de este término), $z_{pot} = b_{pot} \times t^{a_{pot}}$ no se puede ajustar por cuadrados mínimos sin algún tratamiento previo.

En particular, si aplicamos logaritmo natural a ambos términos, obtenemos
$$
\begin{align}
\ln(z_{pot}) &= \ln \left(b_{pot} \times t^{a_{pot}}\right)  \\
\ln(z_{pot}) &=  \ln(b_{pot}) + a_{pot} \times \ln(t)
\end{align}
$$

Es decir que si tomamos $\ln(z_{pot})$ como la variable dependiente y a $\ln(t)$ como la variable independiente, obtenemos un modelo lineal, que sí podemos ajustar por cuadrados mínimos.

A continuación, realizamos las mismas operaciones que para el ajuste del modelo lineal, con el cuidado necesario para convertir entre el modelo potencial original y el auxiliar lineal.

Definimos los vectores auxiliares $\ln(y)$ (`ln_y`) y $\ln(t)$ (`ln_tt`)
```{r variables_logaritmicas}
ln_y <- log(y)
ln_tt <- log(tt)
```

Y luego resolvemos tal como hicimos con el modelo lineal:
```{r ajuste_potencial}
# Defino matriz asociada
A_pot <- matrix(c(uno, ln_tt), nrow = n)

# Sea C = t(A) %*% A,  d = t(A) %*% y x los coeficientes lineales del modelo, tenemos
# C %*% x = d y podemos obtener x como C^-1 %*% d, que se implementa como solve(C,d)
C_pot <- t(A_pot) %*% A_pot
d_pot <- t(A_pot) %*% ln_y
x_pot <- solve(C_pot, d_pot)
```

## Especificación del modelo

Vale recordar que en este modelo potencial linearizado, los coeficientes de $x^{*}_{pot}$ son $\ln(b_{pot})$ y $a_{pot}$, por lo que para reconstruir la función original, tendremos que recuperar $b_{pot}$.

```{r est_pot}
# Extraigo los coeficientes
b_pot <- x_pot[1]
a_pot <- x_pot[2]
# Recupero los coeficientes del modelo no linearizado
b_pot_orig <- exp(b_pot)

est_pot <- function(x) { b_pot_orig * x^a_pot}
```

Esta última función, `est_pot`, codifica el modelo ajustado, que resulta ser
$$
z_{pot}(t) = `r b_pot_orig`  \times t^{`r a_pot`}
$$

## Cálculo del error asociado al modelo

Procedemos al igual que con el modelo lineal:
```{r error_potencial}
z_pot <- est_pot(tt)
err_pot <- (y-z_pot)^2
et_pot <- sqrt(sum(err_pot))
```

Lo que nos da un error total $ET_{pot}=`r et_pot`$


## Estimación potencial de la poblacion para el 2030

Usando la función `est_pot` antes definida, obtenemos una población estimada de `r est_pot(2030)` millones de habitantes.

# Ajuste modelo exponencial


# z_exp = b_exp * e^(t*a_exp)
# Que se lineariza como
# ln(z_exp) = ln(b_exp) + a_exp * t

# Defino matriz asociada
A_exp <- matrix(c(uno, tt), nrow = n)

# Sea C = t(A) %*% A,  d = t(A) %*% y x los coeficientes lineales del modelo, tenemos
# C %*% x = d y podemos obtener x como C^-1 %*% d, que se implementa como solve(C,d)
C_exp <- t(A_exp) %*% A_exp
d_exp <- t(A_exp) %*% ln_y
x_exp <- solve(C_exp, d_exp)

# Extraigo los coeficientes
b_exp <- x_exp[1]
a_exp <- x_exp[2]
# Recupero los coeficientes del modelo no linearizado
b_exp_orig <- exp(b_exp)


# Calculo la estimacion lineal de y, z_lin, y el error asociado al modelo
z_exp <- b_exp_orig * exp(tt*a_exp)
err_exp <- (y-z_exp)^2
et_exp <- sqrt(sum(err_exp))

# Estimo la poblacion segun el modelo exponencial para el 2030
est_2030_exp <- b_exp_orig * exp(a_exp * 2030)


# Preparo grafico
# Funciones de estimacion
fun_lin <- function(x) { b_lin + a_lin * x}
fun_exp <- function(x) { b_exp_orig * exp(a_exp*x)}

grafico <- ggplot(datos, aes(x = anio, y = poblacion)) + geom_point()

grafico +
  stat_function(
    fun = fun_lin,
    color = "blue"
  ) +
  stat_function(
    fun = fun_pot,
    color = "red"
  ) +
  stat_function(
    fun = fun_exp,
    color = "green"
  )

